/*
struct LNode { //Linked List
    int data;
    struct LNode* next;
    LNode(int x){
        data = x;
        next = NULL; }
};
struct TNode {   //Tree
    int data;
    struct TNode* left;
    struct TNode* right;
    TNode(int x){
        data=x;
        left=right=NULL; }
}; */
class Solution {
  public:
    LNode* HelperMiddle(LNode* head) {
        LNode* slowBack = NULL;
        LNode* slow = head;
        LNode* fast = head;
        while(fast -> next && fast -> next -> next) {
            slowBack = slow;
            slow = slow -> next;
            fast = fast -> next -> next;
        }
        if(slowBack) slowBack -> next = NULL;
        return slow;
    }
    
    TNode* HelperMain(LNode* head) {
        if(head == NULL) return NULL;
        
        LNode* mid = HelperMiddle(head);
        TNode* t = new TNode(mid -> data);
        
        if(head == mid) t -> left = NULL;
        else t -> left = HelperMain(head);
        t -> right = HelperMain(mid -> next);
        return t;
    }
    
    LNode* mergeSortMiddle(LNode* head) {
        LNode* slowBack = NULL;
        LNode* slow = head;
        LNode* fast = head;
        while(fast -> next && fast -> next -> next) {
            slowBack = slow;
            slow = slow -> next;
            fast = fast -> next -> next;
        }
        return slowBack;
    }
    
    LNode* merge(LNode* a, LNode* b) {
        if(!a) return b;
        else if(!b) return a;
        
        LNode* sortHead = new LNode(-1);
        LNode* sort = sortHead;
        
        while(a && b) {
            if(a -> data <= b -> data) {
                sort -> next = new LNode(a -> data);
                a = a -> next;
            } else {
                sort -> next = new LNode(b -> data);
                b = b -> next;
            }
            sort = sort -> next;
        }
        while(a) {
            sort -> next = new LNode(a -> data);
            a = a -> next;
            sort = sort -> next;
        }
        while(b) {
            sort -> next = new LNode(b -> data);
            b = b -> next;
            sort = sort -> next;
        }
        
        return sortHead -> next;
    }
    
    LNode* mergeSort(LNode* head) {
        LNode* mid = mergeSortMiddle(head);
        LNode* temp = mid -> next;
        
        mid -> next = NULL;
        
        LNode* temp1 = mergeSort(head);
        LNode* temp2 = mergeSort(temp);
        
        return merge(temp1, temp2);
    }
    
    TNode *sortedListToBST(LNode *head) {
        // code here
        LNode* headNew = mergeSort(head);
        
        return HelperMain(headNew);
    }
};