UNDIRECTED GRAPH : a particular connection b/w two nodes represents bidirectional. 
DIRECTED GRAPH : A -> B, represents connection from A to B but not from B to A.

1) COMPLETE GRAPH : There should be no disconnected component or node. In one way or another, all nodes need to be connected or present as a single entity

2) DISCONNECTED GRAPH(FOREST TYPE) : That means, whole graph is not single entity. We can say that whole graph is two or more separate graphs.

3) 
    1. CYCLIC GRAPH : Graph containing atleast one cycle.
    2. ACYCLIC GRAPH : Graph which don't contain any cycles.

4) EULER GRAPH : Degree of each node is even. (Degree of a node is no. of edges or no. of connections arising from that node)

5) HAMILTONIAN GRAPH : We start from a node, and if we are able to reach that node again and this should be possible for all nodes in the graph. Then it is a hamiltonian graph.


1 -  -  -  - 2
  \        / |
    \   /    |
      \      |
    /   \    |
  /        \ |
4 -  -  -  - 3
for the above graph, the adjacency matrix will be

       1    2    3    4


1      0    1    1    0

2      1    0    1    1

3      1    1    0    1

4      0    1    1    0
    
-> For a undirected graph, the adjacency matrix will be a symmetric matrix.

For the same graph, the adjacency list will be
1 => {2, 3}
2 => {1, 4, 3}
3 => {1, 2, 4}
4 => {2, 3}

If given edges, let's see the code to convert into adjacency matrix and adjacency list

// For adjacency matrix.
int main() {
    vector<vector<int>> edgeList = {{1, 2}, {2, 3}, {3, 4}, {4, 2}, {1, 3}}; // GIVEN. and also let it a undirected graph.
    // Here, 4 is max no., let's say it is maxi

    vector<vector<int>> adjacencyMatrix(maxi + 1, vector<int>(maxi + 1, 0));

    for(int i = 0; i < edgeList.size(); i++) {
        int a = edgeList[i][0];
        int b = edgeList[i][1];

        adjacencyMatrix[a][b] = 1;
        adjacencyMatrix[b][a] = 1;
    }
}

// For adjacency List.
int main() {
    vector<vector<int>> edgeList = {{1, 2}, {2, 3}, {3, 4}, {4, 2}, {1, 3}}; // GIVEN.

    unordered_map<int, vector<int>> graph;

    for(int i = 0; i < edgeList.size(); i++) {
        int a = edgeList[i][0];
        int b = edgeList[i][1];

        graph[a].push_back(b);
        graph[b].push_back(a);   // As undirected graph.
    }
}



GRAPH TRAVERSAL :
1) BFS(BREADTH FIRST SEARCH) : 
2) DFS(DEPTH FIRST SEARCH) : 

 